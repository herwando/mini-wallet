// Code generated by MockGen. DO NOT EDIT.
// Source: module/wallet/handler/usecase.go

// Package mock_handler is a generated GoMock package.
package mock_handler

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	model "github.com/herwando/mini-wallet/module/wallet/entity/model"
)

// MockAccountUsecase is a mock of AccountUsecase interface.
type MockAccountUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockAccountUsecaseMockRecorder
}

// MockAccountUsecaseMockRecorder is the mock recorder for MockAccountUsecase.
type MockAccountUsecaseMockRecorder struct {
	mock *MockAccountUsecase
}

// NewMockAccountUsecase creates a new mock instance.
func NewMockAccountUsecase(ctrl *gomock.Controller) *MockAccountUsecase {
	mock := &MockAccountUsecase{ctrl: ctrl}
	mock.recorder = &MockAccountUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockAccountUsecase) EXPECT() *MockAccountUsecaseMockRecorder {
	return m.recorder
}

// Init mocks base method.
func (m *MockAccountUsecase) Init(ctx context.Context, payload model.Account) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Init", ctx, payload)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Init indicates an expected call of Init.
func (mr *MockAccountUsecaseMockRecorder) Init(ctx, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockAccountUsecase)(nil).Init), ctx, payload)
}

// MockDepositUsecase is a mock of DepositUsecase interface.
type MockDepositUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockDepositUsecaseMockRecorder
}

// MockDepositUsecaseMockRecorder is the mock recorder for MockDepositUsecase.
type MockDepositUsecaseMockRecorder struct {
	mock *MockDepositUsecase
}

// NewMockDepositUsecase creates a new mock instance.
func NewMockDepositUsecase(ctrl *gomock.Controller) *MockDepositUsecase {
	mock := &MockDepositUsecase{ctrl: ctrl}
	mock.recorder = &MockDepositUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDepositUsecase) EXPECT() *MockDepositUsecaseMockRecorder {
	return m.recorder
}

// CreateDeposit mocks base method.
func (m *MockDepositUsecase) CreateDeposit(ctx context.Context, customerXid string, payload model.PayloadDeposit) (*model.Deposit, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateDeposit", ctx, customerXid, payload)
	ret0, _ := ret[0].(*model.Deposit)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateDeposit indicates an expected call of CreateDeposit.
func (mr *MockDepositUsecaseMockRecorder) CreateDeposit(ctx, customerXid, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateDeposit", reflect.TypeOf((*MockDepositUsecase)(nil).CreateDeposit), ctx, customerXid, payload)
}

// MockWalletUsecase is a mock of WalletUsecase interface.
type MockWalletUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockWalletUsecaseMockRecorder
}

// MockWalletUsecaseMockRecorder is the mock recorder for MockWalletUsecase.
type MockWalletUsecaseMockRecorder struct {
	mock *MockWalletUsecase
}

// NewMockWalletUsecase creates a new mock instance.
func NewMockWalletUsecase(ctrl *gomock.Controller) *MockWalletUsecase {
	mock := &MockWalletUsecase{ctrl: ctrl}
	mock.recorder = &MockWalletUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWalletUsecase) EXPECT() *MockWalletUsecaseMockRecorder {
	return m.recorder
}

// Disable mocks base method.
func (m *MockWalletUsecase) Disable(ctx context.Context, customerXid string) (*model.Wallet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Disable", ctx, customerXid)
	ret0, _ := ret[0].(*model.Wallet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Disable indicates an expected call of Disable.
func (mr *MockWalletUsecaseMockRecorder) Disable(ctx, customerXid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disable", reflect.TypeOf((*MockWalletUsecase)(nil).Disable), ctx, customerXid)
}

// Enabled mocks base method.
func (m *MockWalletUsecase) Enabled(ctx context.Context, customerXid string) (*model.Wallet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Enabled", ctx, customerXid)
	ret0, _ := ret[0].(*model.Wallet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Enabled indicates an expected call of Enabled.
func (mr *MockWalletUsecaseMockRecorder) Enabled(ctx, customerXid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enabled", reflect.TypeOf((*MockWalletUsecase)(nil).Enabled), ctx, customerXid)
}

// GetWallet mocks base method.
func (m *MockWalletUsecase) GetWallet(ctx context.Context, customerXid string) (*model.Wallet, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetWallet", ctx, customerXid)
	ret0, _ := ret[0].(*model.Wallet)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetWallet indicates an expected call of GetWallet.
func (mr *MockWalletUsecaseMockRecorder) GetWallet(ctx, customerXid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetWallet", reflect.TypeOf((*MockWalletUsecase)(nil).GetWallet), ctx, customerXid)
}

// MockWithdrawalUsecase is a mock of WithdrawalUsecase interface.
type MockWithdrawalUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockWithdrawalUsecaseMockRecorder
}

// MockWithdrawalUsecaseMockRecorder is the mock recorder for MockWithdrawalUsecase.
type MockWithdrawalUsecaseMockRecorder struct {
	mock *MockWithdrawalUsecase
}

// NewMockWithdrawalUsecase creates a new mock instance.
func NewMockWithdrawalUsecase(ctrl *gomock.Controller) *MockWithdrawalUsecase {
	mock := &MockWithdrawalUsecase{ctrl: ctrl}
	mock.recorder = &MockWithdrawalUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockWithdrawalUsecase) EXPECT() *MockWithdrawalUsecaseMockRecorder {
	return m.recorder
}

// CreateWithdrawal mocks base method.
func (m *MockWithdrawalUsecase) CreateWithdrawal(ctx context.Context, customerXid string, payload model.PayloadWithdrawal) (*model.Withdrawal, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateWithdrawal", ctx, customerXid, payload)
	ret0, _ := ret[0].(*model.Withdrawal)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateWithdrawal indicates an expected call of CreateWithdrawal.
func (mr *MockWithdrawalUsecaseMockRecorder) CreateWithdrawal(ctx, customerXid, payload interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateWithdrawal", reflect.TypeOf((*MockWithdrawalUsecase)(nil).CreateWithdrawal), ctx, customerXid, payload)
}
